{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-mainsail This package aims to provide a simple implementation to bake offline Ark transaction and interact with the blockchain API. REST API >>> from mainsail import rest >>> rest.use_network(\"http://49.13.30.19:4003\") GET >>> # http://xxx.xxx.xxx.xxx:4006/api/wallets/toons >>> wallet = rest.GET.api.wallets.toons() >>> wallet[\"address\"] 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv' >>> rest.GET.api.wallets()[\"meta\"][\"totalCount\"] 89 >>> # use a custop peer >>> custom_peer = {\"ip\": \"49.13.30.19\", \"ports\": {\"api-development\": 4003}} >>> # http://49.13.30.19:4003/api/transactions?type=4 >>> [t[\"blockId\"] for t in rest.GET.api.transactions(type=4, peer=custom_peer)[\"data\"]] ['41afebd995473aab76e8dd7415ab742a6882a08f4c0e0a7305d1a48c551c955c', 'aff37ad0288fadc9d5fdec584d1affab2df0021e86cde3ecb2ba263d6deba3cc'] POST >>> from mainsail.tx.v1 import Transfer >>> t = Transfer(1, 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'message \\U0001f919') >>> t.sign() Type or paste your passphrase > >>> # http://xxx.xxx.xxx.xxx:4007/api/transaction-pool >>> rest.POST.api(\"transaction-pool\", transactions=[t.serialize()]) {'data': {'accept': [0], 'broadcast': [0], 'excess': [], 'invalid': []}} Available transactions Transfer ValidatorRegistration Vote MultiSignature MultiPayment ValidatorResignation UsernameRegistration UsernameResignation","title":"Home"},{"location":"#python-mainsail","text":"This package aims to provide a simple implementation to bake offline Ark transaction and interact with the blockchain API.","title":"python-mainsail"},{"location":"#rest-api","text":">>> from mainsail import rest >>> rest.use_network(\"http://49.13.30.19:4003\")","title":"REST API"},{"location":"#get","text":">>> # http://xxx.xxx.xxx.xxx:4006/api/wallets/toons >>> wallet = rest.GET.api.wallets.toons() >>> wallet[\"address\"] 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv' >>> rest.GET.api.wallets()[\"meta\"][\"totalCount\"] 89 >>> # use a custop peer >>> custom_peer = {\"ip\": \"49.13.30.19\", \"ports\": {\"api-development\": 4003}} >>> # http://49.13.30.19:4003/api/transactions?type=4 >>> [t[\"blockId\"] for t in rest.GET.api.transactions(type=4, peer=custom_peer)[\"data\"]] ['41afebd995473aab76e8dd7415ab742a6882a08f4c0e0a7305d1a48c551c955c', 'aff37ad0288fadc9d5fdec584d1affab2df0021e86cde3ecb2ba263d6deba3cc']","title":"GET"},{"location":"#post","text":">>> from mainsail.tx.v1 import Transfer >>> t = Transfer(1, 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'message \\U0001f919') >>> t.sign() Type or paste your passphrase > >>> # http://xxx.xxx.xxx.xxx:4007/api/transaction-pool >>> rest.POST.api(\"transaction-pool\", transactions=[t.serialize()]) {'data': {'accept': [0], 'broadcast': [0], 'excess': [], 'invalid': []}}","title":"POST"},{"location":"#available-transactions","text":"Transfer ValidatorRegistration Vote MultiSignature MultiPayment ValidatorResignation UsernameRegistration UsernameResignation","title":"Available transactions"},{"location":"identity/","text":"Module mainsail.identity This modules provides cryptographic primitives to interact with blockchain. >>> from mainsail import identity KeyRing Objects class KeyRing(cSecp256k1.KeyRing) Subclass of cSecp256K1.KeyRing allowing secure filesystem saving and loading. It is also linked to mainsail network configuration to select appropriate Schnorr signature specification (bcrypto 4.10 or BIP 340) to be applied. >>> import os >>> signer = identity.KeyRing.create(int.from_bytes(os.urandom(32))) >>> signer # KeyRing is a subclass of builtin int 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> sig = signer.sign(\"simple message\") >>> puk = signer.puk() # compute associated public key >>> signer.verify(puk, \"simple message\", sig) True >>> type(signer) # bcrypto 4.10 specification used <class 'mainsail.identity.Bcrpt410'> KeyRing.dump def dump(pin: Union[bytes, List[int]]) -> None Securely dump KeyRing into filesystem using pin code. Override existing file if any. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. >>> signer.dump([0, 0, 0, 0]) # dump into filesystem using pin 0000 >>> signer.dump(b\"\\x00\\x00\\x00\\x00\") # equivalent KeyRing.load @staticmethod def load(pin: Union[bytes, List[int]]) Securely load KeyRing from filesystem using pin code. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. Returns : Schnorr|Bcrpt410 - signer object. >>> identity.KeyRing.load([0, 0, 0, 0]) 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> identity.KeyRing.load(b\"\\x00\\x00\\x00\\x00\") 40367812022907163119325945335177282621496014100307111368749805816184299969919 KeyRing.create @staticmethod def create(obj: int = None) Create a KeyRing signer subclass with the appropriate schnorr signature specification. Arguments : obj int - the value of the private key. Returns : Schnorr|Bcrpt410 - signer object. get_signer def get_signer() Returns the the network appropriate signer. bip39_hash def bip39_hash(secret: str, passphrase: str = \"\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string. sign def sign(data: Union[str, bytes], prk: Union[KeyRing, List[int], str, int] = None, format: str = \"raw\") -> str Compute Schnorr signature from data using private key according to bcrypto 4.10 spec or BIP340 specification. Signature format is RAW by defaul but can also be specified a DER. >>> prk = identity.KeyRing.load([0,0,0,0]) >>> identity.sign(\"simple message\", [0, 0, 0, 0]) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", 40367812022907163119325945335177282621496014100307111368749805816184299969919) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk, \"der\") '304402205993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd00220026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' Arguments : data str|bytes - data used for signature computation. prk KeyRing|List[int]|str|int - private key, keyring or pin code. format str - raw or der to determine signature format output. Returns : str - Schnorr signature in raw format (ie r | s) by default. user_keys def user_keys(secret: Union[int, str]) -> dict Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str|int - anything that could issue a private key on secp256k1 curve. Returns : dict - public, private and WIF keys. wif_keys def wif_keys(seed: bytes) -> Union[str, None] Compute WIF key from seed. Arguments : seed bytes - a 32 length bytes string. Returns : str - the WIF key.","title":"Identity"},{"location":"identity/#module-mainsailidentity","text":"This modules provides cryptographic primitives to interact with blockchain. >>> from mainsail import identity","title":"Module mainsail.identity"},{"location":"identity/#keyring-objects","text":"class KeyRing(cSecp256k1.KeyRing) Subclass of cSecp256K1.KeyRing allowing secure filesystem saving and loading. It is also linked to mainsail network configuration to select appropriate Schnorr signature specification (bcrypto 4.10 or BIP 340) to be applied. >>> import os >>> signer = identity.KeyRing.create(int.from_bytes(os.urandom(32))) >>> signer # KeyRing is a subclass of builtin int 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> sig = signer.sign(\"simple message\") >>> puk = signer.puk() # compute associated public key >>> signer.verify(puk, \"simple message\", sig) True >>> type(signer) # bcrypto 4.10 specification used <class 'mainsail.identity.Bcrpt410'>","title":"KeyRing Objects"},{"location":"identity/#keyringdump","text":"def dump(pin: Union[bytes, List[int]]) -> None Securely dump KeyRing into filesystem using pin code. Override existing file if any. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. >>> signer.dump([0, 0, 0, 0]) # dump into filesystem using pin 0000 >>> signer.dump(b\"\\x00\\x00\\x00\\x00\") # equivalent","title":"KeyRing.dump"},{"location":"identity/#keyringload","text":"@staticmethod def load(pin: Union[bytes, List[int]]) Securely load KeyRing from filesystem using pin code. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. Returns : Schnorr|Bcrpt410 - signer object. >>> identity.KeyRing.load([0, 0, 0, 0]) 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> identity.KeyRing.load(b\"\\x00\\x00\\x00\\x00\") 40367812022907163119325945335177282621496014100307111368749805816184299969919","title":"KeyRing.load"},{"location":"identity/#keyringcreate","text":"@staticmethod def create(obj: int = None) Create a KeyRing signer subclass with the appropriate schnorr signature specification. Arguments : obj int - the value of the private key. Returns : Schnorr|Bcrpt410 - signer object.","title":"KeyRing.create"},{"location":"identity/#get_signer","text":"def get_signer() Returns the the network appropriate signer.","title":"get_signer"},{"location":"identity/#bip39_hash","text":"def bip39_hash(secret: str, passphrase: str = \"\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string.","title":"bip39_hash"},{"location":"identity/#sign","text":"def sign(data: Union[str, bytes], prk: Union[KeyRing, List[int], str, int] = None, format: str = \"raw\") -> str Compute Schnorr signature from data using private key according to bcrypto 4.10 spec or BIP340 specification. Signature format is RAW by defaul but can also be specified a DER. >>> prk = identity.KeyRing.load([0,0,0,0]) >>> identity.sign(\"simple message\", [0, 0, 0, 0]) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", 40367812022907163119325945335177282621496014100307111368749805816184299969919) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk, \"der\") '304402205993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd00220026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' Arguments : data str|bytes - data used for signature computation. prk KeyRing|List[int]|str|int - private key, keyring or pin code. format str - raw or der to determine signature format output. Returns : str - Schnorr signature in raw format (ie r | s) by default.","title":"sign"},{"location":"identity/#user_keys","text":"def user_keys(secret: Union[int, str]) -> dict Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str|int - anything that could issue a private key on secp256k1 curve. Returns : dict - public, private and WIF keys.","title":"user_keys"},{"location":"identity/#wif_keys","text":"def wif_keys(seed: bytes) -> Union[str, None] Compute WIF key from seed. Arguments : seed bytes - a 32 length bytes string. Returns : str - the WIF key.","title":"wif_keys"}]}