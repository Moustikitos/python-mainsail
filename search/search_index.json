{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-mainsail This package provides a simple implementation to interact with Ark blockchain API and managment tools for validators aiming to run a pool . >>> from mainsail.tx.v1 import Transfer >>> from mainsail import rest >>> # http://xxx.xxx.xxx.xxx:4006/api/wallets/toons >>> wallet = rest.GET.api.wallets.toons() >>> wallet[\"address\"] 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv' >>> rest.GET.api.wallets()[\"meta\"][\"totalCount\"] 89 >>> # use a custop peer >>> custom_peer = {\"ip\": \"49.13.30.19\", \"ports\": {\"api-development\": 4003}} >>> # http://49.13.30.19:4003/api/transactions?type=4 >>> [t[\"blockId\"] for t in rest.GET.api.transactions(type=4, peer=custom_peer)[\"data\"]] ['41afebd995473aab76e8dd7415ab742a6882a08f4c0e0a7305d1a48c551c955c', 'aff37ad0288fadc9d5fdec584d1affab2df0021e86cde3ecb2ba263d6deba3cc'] >>> t = Transfer(1, 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'message \\U0001f919') >>> t.sign() Type or paste your passphrase > >>> t.send() {'data': {'accept': [0], 'broadcast': [0], 'excess': [], 'invalid': []}} Linux distributions Due to RIPEMD160 issue with OpenSSL v>=3 , hashlib.ripemd160 is disabled within python3 . To enable it back, get the installation folder\u2026 openssl version -d \u2026 and make sure that the openssl config file contains following lines: openssl_conf = openssl_init [openssl_init] providers = provider_sect [provider_sect] default = default_sect legacy = legacy_sect [default_sect] activate = 1 [legacy_sect] activate = 1 Available transactions Transfer ValidatorRegistration Vote MultiSignature MultiPayment ValidatorResignation UsernameRegistration UsernameResignation Features secured private keys storage secured webhook subscriptions storage offline network configuration available pool server with remote managment tool cmd command line set_pool for windows platform pool installation and update using pip Support this project","title":"Home"},{"location":"#python-mainsail","text":"This package provides a simple implementation to interact with Ark blockchain API and managment tools for validators aiming to run a pool . >>> from mainsail.tx.v1 import Transfer >>> from mainsail import rest >>> # http://xxx.xxx.xxx.xxx:4006/api/wallets/toons >>> wallet = rest.GET.api.wallets.toons() >>> wallet[\"address\"] 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv' >>> rest.GET.api.wallets()[\"meta\"][\"totalCount\"] 89 >>> # use a custop peer >>> custom_peer = {\"ip\": \"49.13.30.19\", \"ports\": {\"api-development\": 4003}} >>> # http://49.13.30.19:4003/api/transactions?type=4 >>> [t[\"blockId\"] for t in rest.GET.api.transactions(type=4, peer=custom_peer)[\"data\"]] ['41afebd995473aab76e8dd7415ab742a6882a08f4c0e0a7305d1a48c551c955c', 'aff37ad0288fadc9d5fdec584d1affab2df0021e86cde3ecb2ba263d6deba3cc'] >>> t = Transfer(1, 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'message \\U0001f919') >>> t.sign() Type or paste your passphrase > >>> t.send() {'data': {'accept': [0], 'broadcast': [0], 'excess': [], 'invalid': []}}","title":"python-mainsail"},{"location":"#linux-distributions","text":"Due to RIPEMD160 issue with OpenSSL v>=3 , hashlib.ripemd160 is disabled within python3 . To enable it back, get the installation folder\u2026 openssl version -d \u2026 and make sure that the openssl config file contains following lines: openssl_conf = openssl_init [openssl_init] providers = provider_sect [provider_sect] default = default_sect legacy = legacy_sect [default_sect] activate = 1 [legacy_sect] activate = 1","title":"Linux distributions"},{"location":"#available-transactions","text":"Transfer ValidatorRegistration Vote MultiSignature MultiPayment ValidatorResignation UsernameRegistration UsernameResignation","title":"Available transactions"},{"location":"#features","text":"secured private keys storage secured webhook subscriptions storage offline network configuration available pool server with remote managment tool cmd command line set_pool for windows platform pool installation and update using pip","title":"Features"},{"location":"#support-this-project","text":"","title":"Support this project"},{"location":"identity/","text":"identity This modules provides cryptographic primitives to interact with blockchain. >>> from mainsail import identity KeyRing Objects class KeyRing(cSecp256k1.KeyRing) Subclass of cSecp256K1.KeyRing allowing secure filesystem saving and loading. It is also linked to mainsail network configuration to select appropriate Schnorr signature specification (bcrypto 4.10 or BIP 340) to be applied. >>> import os >>> signer = identity.KeyRing.create(int.from_bytes(os.urandom(32))) >>> signer # KeyRing is a subclass of builtin int 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> sig = signer.sign(\"simple message\") >>> puk = signer.puk() # compute associated public key >>> signer.verify(puk, \"simple message\", sig) True >>> type(signer) # bcrypto 4.10 specification used <class 'mainsail.identity.Bcrpt410'> KeyRing.dump def dump(pin: Union[bytes, List[int]]) -> None Securely dump KeyRing into filesystem using pin code. Override existing file if any. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. >>> signer.dump([0, 0, 0, 0]) # dump into filesystem using pin 0000 >>> signer.dump(b\"\\x00\\x00\\x00\\x00\") # equivalent KeyRing.load @staticmethod def load(pin: Union[bytes, List[int]]) Securely load KeyRing from filesystem using pin code. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. Returns : Schnorr|Bcrpt410 - signer object. >>> identity.KeyRing.load([0, 0, 0, 0]) 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> identity.KeyRing.load(b\"\\x00\\x00\\x00\\x00\") 40367812022907163119325945335177282621496014100307111368749805816184299969919 KeyRing.create @staticmethod def create(obj: int = None) Create a KeyRing signer subclass with the appropriate schnorr signature specification. Arguments : obj int - the value of the private key. Returns : Schnorr|Bcrpt410 - signer object. get_signer def get_signer() Returns the the network appropriate signer. bip39_hash def bip39_hash(secret: str, passphrase: str = \"\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string. sign def sign(data: Union[str, bytes], prk: Union[KeyRing, List[int], str, int] = None, format: str = \"raw\") -> str Compute Schnorr signature from data using private key according to bcrypto 4.10 spec or BIP340 specification. Signature format is RAW by defaul but can also be specified a DER. >>> prk = identity.KeyRing.load([0,0,0,0]) >>> identity.sign(\"simple message\", [0, 0, 0, 0]) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", 40367812022907163119325945335177282621496014100307111368749805816184299969919) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk, \"der\") '304402205993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd00220026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' Arguments : data str|bytes - data used for signature computation. prk KeyRing|List[int]|str|int - private key, keyring or pin code. format str - raw or der to determine signature format output. Returns : str - Schnorr signature in raw format (ie r | s) by default. user_keys def user_keys(secret: Union[int, str]) -> dict Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str|int - anything that could issue a private key on secp256k1 curve. Returns : dict - public, private and WIF keys. wif_keys def wif_keys(seed: bytes) -> Union[str, None] Compute WIF key from seed. Arguments : seed bytes - a 32 length bytes string. Returns : str - the WIF key.","title":"Identity"},{"location":"identity/#identity","text":"This modules provides cryptographic primitives to interact with blockchain. >>> from mainsail import identity","title":"identity"},{"location":"identity/#keyring-objects","text":"class KeyRing(cSecp256k1.KeyRing) Subclass of cSecp256K1.KeyRing allowing secure filesystem saving and loading. It is also linked to mainsail network configuration to select appropriate Schnorr signature specification (bcrypto 4.10 or BIP 340) to be applied. >>> import os >>> signer = identity.KeyRing.create(int.from_bytes(os.urandom(32))) >>> signer # KeyRing is a subclass of builtin int 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> sig = signer.sign(\"simple message\") >>> puk = signer.puk() # compute associated public key >>> signer.verify(puk, \"simple message\", sig) True >>> type(signer) # bcrypto 4.10 specification used <class 'mainsail.identity.Bcrpt410'>","title":"KeyRing Objects"},{"location":"identity/#keyringdump","text":"def dump(pin: Union[bytes, List[int]]) -> None Securely dump KeyRing into filesystem using pin code. Override existing file if any. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. >>> signer.dump([0, 0, 0, 0]) # dump into filesystem using pin 0000 >>> signer.dump(b\"\\x00\\x00\\x00\\x00\") # equivalent","title":"KeyRing.dump"},{"location":"identity/#keyringload","text":"@staticmethod def load(pin: Union[bytes, List[int]]) Securely load KeyRing from filesystem using pin code. Arguments : pin bytes|List[int] - pin code used to _encrypt KeyRing. Pin code may be a list of short (0 < int < 255) or a bytes string. Returns : Schnorr|Bcrpt410 - signer object. >>> identity.KeyRing.load([0, 0, 0, 0]) 40367812022907163119325945335177282621496014100307111368749805816184299969919 >>> identity.KeyRing.load(b\"\\x00\\x00\\x00\\x00\") 40367812022907163119325945335177282621496014100307111368749805816184299969919","title":"KeyRing.load"},{"location":"identity/#keyringcreate","text":"@staticmethod def create(obj: int = None) Create a KeyRing signer subclass with the appropriate schnorr signature specification. Arguments : obj int - the value of the private key. Returns : Schnorr|Bcrpt410 - signer object.","title":"KeyRing.create"},{"location":"identity/#get_signer","text":"def get_signer() Returns the the network appropriate signer.","title":"get_signer"},{"location":"identity/#bip39_hash","text":"def bip39_hash(secret: str, passphrase: str = \"\") -> bytes Returns bip39 hash bytes string. This function does not check mnemonic integrity. Arguments : secret str - a mnemonic string. passphrase str - salt string. Returns : bytes - 64 length bytes string.","title":"bip39_hash"},{"location":"identity/#sign","text":"def sign(data: Union[str, bytes], prk: Union[KeyRing, List[int], str, int] = None, format: str = \"raw\") -> str Compute Schnorr signature from data using private key according to bcrypto 4.10 spec or BIP340 specification. Signature format is RAW by defaul but can also be specified a DER. >>> prk = identity.KeyRing.load([0,0,0,0]) >>> identity.sign(\"simple message\", [0, 0, 0, 0]) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", 40367812022907163119325945335177282621496014100307111368749805816184299969919) '5993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd0026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' >>> identity.sign(\"simple message\", prk, \"der\") '304402205993cfb3d7dafdfe58a29e0dfc9ef332acc7bb1429ba720b20e7ea6b4a961dd00220026ed229f5095581188816bf120bcad0d25cdada03a3add04bd539ab2ba3becb' Arguments : data str|bytes - data used for signature computation. prk KeyRing|List[int]|str|int - private key, keyring or pin code. format str - raw or der to determine signature format output. Returns : str - Schnorr signature in raw format (ie r | s) by default.","title":"sign"},{"location":"identity/#user_keys","text":"def user_keys(secret: Union[int, str]) -> dict Generate keyring containing secp256k1 keys-pair and wallet import format (WIF). Arguments : secret str|int - anything that could issue a private key on secp256k1 curve. Returns : dict - public, private and WIF keys.","title":"user_keys"},{"location":"identity/#wif_keys","text":"def wif_keys(seed: bytes) -> Union[str, None] Compute WIF key from seed. Arguments : seed bytes - a 32 length bytes string. Returns : str - the WIF key.","title":"wif_keys"},{"location":"pool/","text":"mnsl_pool This package provides managment tools to run a pool on arkEcosystem mainsail framework. It computes a true block weight (TBW) distribution of reward according to instant participant vote weight. Ubuntu installation First read installation script , then: ~$ bash <(wget -qO- https://bit.ly/3U6BI8v) Setup script creates 8 commands into ~/.bash_aliases file: mnsl_install install a specific version mnsl_deploy takes broadcast ip address and port to create services managed by systemd . add_pool takes a validator public key to configure listening subscription on blockchain. set_pool modifies validator TBW pool service parameters. mnsl_venv activates the virtual environment used to run mainsail pool. mnsl_restart restarts pool tasks. log_mnsl_pool shows server logs. log_mnsl_bg shows background tasks logs. biom deploy def deploy(host: str = \"127.0.0.1\", port: int = 5000) Deploy pool server >>> from mnsl_pool import biom >>> biom.deploy() ~$ mnsl_deploy # use ip address 0.0.0.0 with port `5000` If you plan to deploy pool server behind a proxy, it is possible to customize ip and port : ~$ mnsl_deploy host=127.0.0.1 port=7542 # use localhost address with port `7542` add_pool def add_pool(**kwargs) -> None Initialize a pool >>> from mnsl_pool import biom >>> biom.add_pool(puk=\"033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504db\") ~$ add_pool puk=033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba INFO:mnsl_pool.biom:grabed options: {'puk': '033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba'} Type or paste your passphrase > enter pin code to secure secret (only figures)> provide a network peer API [default=localhost:4003]> provide your webhook peer [default=localhost:4004]> provide your target server [default=localhost:5000]> INFO:mnsl_pool.biom:grabed options: {'prk': [0, 0, 0, 0], 'nethash': '7b9a7c6a14d3f8fb3f47c434b8c6ef0843d5622f6c209ffeec5411aabbf4bf1c', 'webhook': '47f4ede0-1dcb-4653-b9a2-20e766fc31d5', 'puk': '033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba'} INFO:mnsl_pool.biom:delegate 033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba set Check your pool using two endpoits: http://{ip}:{port}/{puk or username} http://{ip}:{port}/{puk or username}/forgery Pool data are stored in ~/.mainsail folder. set_pool def set_pool(**kwargs) -> requests.Response Configure a pool >>> from mnsl_pool import biom >>> addresses = [ ... \"D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv\", ... \"DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU\" ... ] >>> biom.set_pool(share=0.7, min_vote=10.0, exlusives=addresses) $ set_pool --share=0.7 --min-vote=10.0 --exclusives=D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv,DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU INFO:pool.biom:grabed options: {'share': 0.7, 'min_vote': 10.0, 'exclusives': 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv,DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU'} enter validator security pincode> {'status': 204, 'updated': {'exclusives': ['D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU'], 'min_vote': 10.0, 'share': 0.7}} available parameters: share - share rate in float number (0. <= share = 1.0). min_vote - minimum vote to be considered by the pool. max_vote - maximum vote weight caped in the pool. min_share - minimum reward to reach for a vote wallet to be included in payroll. excludes - comma-separated list of wallet to exclude. exclusives - comma-separated list of private pool wallets. block_delay - number of forged block between two payrolls. message - vendorFied message to be set on each payroll transacion. chunck_size - maximum number of recipient for a multipayment. wallet - custom wallet to receive validator share. excludes & exclusives Those parameter accept a custom action to add or remove item from list. (excludes|exclusives):[add|pop]=coma,separated,list,of,valid,addresses","title":"Pool"},{"location":"pool/#mnsl_pool","text":"This package provides managment tools to run a pool on arkEcosystem mainsail framework. It computes a true block weight (TBW) distribution of reward according to instant participant vote weight.","title":"mnsl_pool"},{"location":"pool/#ubuntu-installation","text":"First read installation script , then: ~$ bash <(wget -qO- https://bit.ly/3U6BI8v) Setup script creates 8 commands into ~/.bash_aliases file: mnsl_install install a specific version mnsl_deploy takes broadcast ip address and port to create services managed by systemd . add_pool takes a validator public key to configure listening subscription on blockchain. set_pool modifies validator TBW pool service parameters. mnsl_venv activates the virtual environment used to run mainsail pool. mnsl_restart restarts pool tasks. log_mnsl_pool shows server logs. log_mnsl_bg shows background tasks logs.","title":"Ubuntu installation"},{"location":"pool/#biom","text":"","title":"biom"},{"location":"pool/#deploy","text":"def deploy(host: str = \"127.0.0.1\", port: int = 5000) Deploy pool server >>> from mnsl_pool import biom >>> biom.deploy() ~$ mnsl_deploy # use ip address 0.0.0.0 with port `5000` If you plan to deploy pool server behind a proxy, it is possible to customize ip and port : ~$ mnsl_deploy host=127.0.0.1 port=7542 # use localhost address with port `7542`","title":"deploy"},{"location":"pool/#add_pool","text":"def add_pool(**kwargs) -> None Initialize a pool >>> from mnsl_pool import biom >>> biom.add_pool(puk=\"033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504db\") ~$ add_pool puk=033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba INFO:mnsl_pool.biom:grabed options: {'puk': '033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba'} Type or paste your passphrase > enter pin code to secure secret (only figures)> provide a network peer API [default=localhost:4003]> provide your webhook peer [default=localhost:4004]> provide your target server [default=localhost:5000]> INFO:mnsl_pool.biom:grabed options: {'prk': [0, 0, 0, 0], 'nethash': '7b9a7c6a14d3f8fb3f47c434b8c6ef0843d5622f6c209ffeec5411aabbf4bf1c', 'webhook': '47f4ede0-1dcb-4653-b9a2-20e766fc31d5', 'puk': '033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba'} INFO:mnsl_pool.biom:delegate 033f786d4875bcae61eb934e6af74090f254d7a0c955263d1ec9c504dbba5477ba set Check your pool using two endpoits: http://{ip}:{port}/{puk or username} http://{ip}:{port}/{puk or username}/forgery Pool data are stored in ~/.mainsail folder.","title":"add_pool"},{"location":"pool/#set_pool","text":"def set_pool(**kwargs) -> requests.Response Configure a pool >>> from mnsl_pool import biom >>> addresses = [ ... \"D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv\", ... \"DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU\" ... ] >>> biom.set_pool(share=0.7, min_vote=10.0, exlusives=addresses) $ set_pool --share=0.7 --min-vote=10.0 --exclusives=D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv,DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU INFO:pool.biom:grabed options: {'share': 0.7, 'min_vote': 10.0, 'exclusives': 'D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv,DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU'} enter validator security pincode> {'status': 204, 'updated': {'exclusives': ['D5Ha4o3UTuTd59vjDw1F26mYhaRdXh7YPv', 'DTGgFwrVGf5JpvkMSp8QR5seEJ6tCAWFyU'], 'min_vote': 10.0, 'share': 0.7}} available parameters: share - share rate in float number (0. <= share = 1.0). min_vote - minimum vote to be considered by the pool. max_vote - maximum vote weight caped in the pool. min_share - minimum reward to reach for a vote wallet to be included in payroll. excludes - comma-separated list of wallet to exclude. exclusives - comma-separated list of private pool wallets. block_delay - number of forged block between two payrolls. message - vendorFied message to be set on each payroll transacion. chunck_size - maximum number of recipient for a multipayment. wallet - custom wallet to receive validator share. excludes & exclusives Those parameter accept a custom action to add or remove item from list. (excludes|exclusives):[add|pop]=coma,separated,list,of,valid,addresses","title":"set_pool"},{"location":"webhook-api/","text":"webhook condition def condition(expr: str) -> dict Webhook condition builder from str expression. td,th{border:none!important;text-align:left;} webhook expr lt / lte < / <= gt / gte > / >= eq / ne == / != truthy / falsy ? / !? REGEXP / contains \\ / $ between / not-between <> / !<> >>> from mainsail import webhook >>> webhook.condition(\"vendorField\\^.*payroll.*$\") {'value': '^.*payroll.*$', 'key': 'vendorField', 'condition': 'regexp'} >>> webhook.condition(\"amount<>2000000000000:4000000000000\") {'value': {'min': '2000000000000', 'max': '4000000000000'}, 'condition': 'between', 'key': 'amount'} Arguments : expr str - human readable expression. Returns : dict - webhook conditions","title":"Webhook API"},{"location":"webhook-api/#webhook","text":"","title":"webhook"},{"location":"webhook-api/#condition","text":"def condition(expr: str) -> dict Webhook condition builder from str expression. td,th{border:none!important;text-align:left;} webhook expr lt / lte < / <= gt / gte > / >= eq / ne == / != truthy / falsy ? / !? REGEXP / contains \\ / $ between / not-between <> / !<> >>> from mainsail import webhook >>> webhook.condition(\"vendorField\\^.*payroll.*$\") {'value': '^.*payroll.*$', 'key': 'vendorField', 'condition': 'regexp'} >>> webhook.condition(\"amount<>2000000000000:4000000000000\") {'value': {'min': '2000000000000', 'max': '4000000000000'}, 'condition': 'between', 'key': 'amount'} Arguments : expr str - human readable expression. Returns : dict - webhook conditions","title":"condition"}]}